<?php
/**
 * PaymentinstrumentsCard
 *
 * PHP version 5
 *
 * @category Class
 * @package  CyberSource
 * @author   Swaagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * CyberSource Flex API
 *
 * Simple PAN tokenization service
 *
 * OpenAPI spec version: 0.0.1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace CyberSource\Model;

use \ArrayAccess;

/**
 * PaymentinstrumentsCard Class Doc Comment
 *
 * @category    Class
 * @package     CyberSource
 * @author      Swagger Codegen team
 * @link        https://github.com/swagger-api/swagger-codegen
 */
class PaymentinstrumentsCard implements ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      * @var string
      */
    protected static $swaggerModelName = 'paymentinstruments_card';

    /**
      * Array of property to type mappings. Used for (de)serialization
      * @var string[]
      */
    protected static $swaggerTypes = [
        'expirationMonth' => 'string',
        'expirationYear' => 'string',
        'type' => 'string',
        'issueNumber' => 'string',
        'startMonth' => 'string',
        'startYear' => 'string',
        'useAs' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      * @var string[]
      */
    protected static $swaggerFormats = [
        'expirationMonth' => null,
        'expirationYear' => null,
        'type' => null,
        'issueNumber' => null,
        'startMonth' => null,
        'startYear' => null,
        'useAs' => null
    ];

    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name, and the value is the original name
     * @var string[]
     */
    protected static $attributeMap = [
        'expirationMonth' => 'expirationMonth',
        'expirationYear' => 'expirationYear',
        'type' => 'type',
        'issueNumber' => 'issueNumber',
        'startMonth' => 'startMonth',
        'startYear' => 'startYear',
        'useAs' => 'useAs'
    ];


    /**
     * Array of attributes to setter functions (for deserialization of responses)
     * @var string[]
     */
    protected static $setters = [
        'expirationMonth' => 'setExpirationMonth',
        'expirationYear' => 'setExpirationYear',
        'type' => 'setType',
        'issueNumber' => 'setIssueNumber',
        'startMonth' => 'setStartMonth',
        'startYear' => 'setStartYear',
        'useAs' => 'setUseAs'
    ];


    /**
     * Array of attributes to getter functions (for serialization of requests)
     * @var string[]
     */
    protected static $getters = [
        'expirationMonth' => 'getExpirationMonth',
        'expirationYear' => 'getExpirationYear',
        'type' => 'getType',
        'issueNumber' => 'getIssueNumber',
        'startMonth' => 'getStartMonth',
        'startYear' => 'getStartYear',
        'useAs' => 'getUseAs'
    ];

    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    public static function setters()
    {
        return self::$setters;
    }

    public static function getters()
    {
        return self::$getters;
    }

    const TYPE_VISA = 'visa';
    const TYPE_MASTERCARD = 'mastercard';
    const TYPE_AMERICAN_EXPRESS = 'american express';
    const TYPE_DISCOVER = 'discover';
    const TYPE_DINERS_CLUB = 'diners club';
    const TYPE_CARTE_BLANCHE = 'carte blanche';
    const TYPE_JCB = 'jcb';
    const TYPE_OPTIMA = 'optima';
    const TYPE_TWINPAY_CREDIT = 'twinpay credit';
    const TYPE_TWINPAY_DEBIT = 'twinpay debit';
    const TYPE_WALMART = 'walmart';
    const TYPE_ENROUTE = 'enroute';
    const TYPE_LOWES_CONSUMER = 'lowes consumer';
    const TYPE_HOME_DEPOT_CONSUMER = 'home depot consumer';
    const TYPE_MBNA = 'mbna';
    const TYPE_DICKS_SPORTSWEAR = 'dicks sportswear';
    const TYPE_CASUAL_CORNER = 'casual corner';
    const TYPE_SEARS = 'sears';
    const TYPE_JAL = 'jal';
    const TYPE_DISNEY = 'disney';
    const TYPE_MAESTRO_UK_DOMESTIC = 'maestro uk domestic';
    const TYPE_SAMS_CLUB_CONSUMER = 'sams club consumer';
    const TYPE_SAMS_CLUB_BUSINESS = 'sams club business';
    const TYPE_NICOS = 'nicos';
    const TYPE_BILL_ME_LATER = 'bill me later';
    const TYPE_BEBE = 'bebe';
    const TYPE_RESTORATION_HARDWARE = 'restoration hardware';
    const TYPE_DELTA_ONLINE = 'delta online';
    const TYPE_SOLO = 'solo';
    const TYPE_VISA_ELECTRON = 'visa electron';
    const TYPE_DANKORT = 'dankort';
    const TYPE_LASER = 'laser';
    const TYPE_CARTE_BLEUE = 'carte bleue';
    const TYPE_CARTA_SI = 'carta si';
    const TYPE_PINLESS_DEBIT = 'pinless debit';
    const TYPE_ENCODED_ACCOUNT = 'encoded account';
    const TYPE_UATP = 'uatp';
    const TYPE_HOUSEHOLD = 'household';
    const TYPE_MAESTRO_INTERNATIONAL = 'maestro international';
    const TYPE_GE_MONEY_UK = 'ge money uk';
    const TYPE_KOREAN_CARDS = 'korean cards';
    const TYPE_STYLE = 'style';
    const TYPE_JCREW = 'jcrew';
    const TYPE_PAYEASE_CHINA_PROCESSING_EWALLET = 'payease china processing ewallet';
    const TYPE_PAYEASE_CHINA_PROCESSING_BANK_TRANSFER = 'payease china processing bank transfer';
    const TYPE_MEIJER_PRIVATE_LABEL = 'meijer private label';
    const TYPE_HIPERCARD = 'hipercard';
    const TYPE_AURA = 'aura';
    const TYPE_REDECARD = 'redecard';
    const TYPE_ORICO = 'orico';
    const TYPE_ELO = 'elo';
    const TYPE_CAPITAL_ONE_PRIVATE_LABEL = 'capital one private label';
    const TYPE_SYNCHRONY_PRIVATE_LABEL = 'synchrony private label';
    const TYPE_CHINA_UNION_PAY = 'china union pay';
    

    
    /**
     * Gets allowable values of the enum
     * @return string[]
     */
    public function getTypeAllowableValues()
    {
        return [
            self::TYPE_VISA,
            self::TYPE_MASTERCARD,
            self::TYPE_AMERICAN_EXPRESS,
            self::TYPE_DISCOVER,
            self::TYPE_DINERS_CLUB,
            self::TYPE_CARTE_BLANCHE,
            self::TYPE_JCB,
            self::TYPE_OPTIMA,
            self::TYPE_TWINPAY_CREDIT,
            self::TYPE_TWINPAY_DEBIT,
            self::TYPE_WALMART,
            self::TYPE_ENROUTE,
            self::TYPE_LOWES_CONSUMER,
            self::TYPE_HOME_DEPOT_CONSUMER,
            self::TYPE_MBNA,
            self::TYPE_DICKS_SPORTSWEAR,
            self::TYPE_CASUAL_CORNER,
            self::TYPE_SEARS,
            self::TYPE_JAL,
            self::TYPE_DISNEY,
            self::TYPE_MAESTRO_UK_DOMESTIC,
            self::TYPE_SAMS_CLUB_CONSUMER,
            self::TYPE_SAMS_CLUB_BUSINESS,
            self::TYPE_NICOS,
            self::TYPE_BILL_ME_LATER,
            self::TYPE_BEBE,
            self::TYPE_RESTORATION_HARDWARE,
            self::TYPE_DELTA_ONLINE,
            self::TYPE_SOLO,
            self::TYPE_VISA_ELECTRON,
            self::TYPE_DANKORT,
            self::TYPE_LASER,
            self::TYPE_CARTE_BLEUE,
            self::TYPE_CARTA_SI,
            self::TYPE_PINLESS_DEBIT,
            self::TYPE_ENCODED_ACCOUNT,
            self::TYPE_UATP,
            self::TYPE_HOUSEHOLD,
            self::TYPE_MAESTRO_INTERNATIONAL,
            self::TYPE_GE_MONEY_UK,
            self::TYPE_KOREAN_CARDS,
            self::TYPE_STYLE,
            self::TYPE_JCREW,
            self::TYPE_PAYEASE_CHINA_PROCESSING_EWALLET,
            self::TYPE_PAYEASE_CHINA_PROCESSING_BANK_TRANSFER,
            self::TYPE_MEIJER_PRIVATE_LABEL,
            self::TYPE_HIPERCARD,
            self::TYPE_AURA,
            self::TYPE_REDECARD,
            self::TYPE_ORICO,
            self::TYPE_ELO,
            self::TYPE_CAPITAL_ONE_PRIVATE_LABEL,
            self::TYPE_SYNCHRONY_PRIVATE_LABEL,
            self::TYPE_CHINA_UNION_PAY,
        ];
    }
    

    /**
     * Associative array for storing property values
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     * @param mixed[] $data Associated array of property values initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['expirationMonth'] = isset($data['expirationMonth']) ? $data['expirationMonth'] : null;
        $this->container['expirationYear'] = isset($data['expirationYear']) ? $data['expirationYear'] : null;
        $this->container['type'] = isset($data['type']) ? $data['type'] : null;
        $this->container['issueNumber'] = isset($data['issueNumber']) ? $data['issueNumber'] : null;
        $this->container['startMonth'] = isset($data['startMonth']) ? $data['startMonth'] : null;
        $this->container['startYear'] = isset($data['startYear']) ? $data['startYear'] : null;
        $this->container['useAs'] = isset($data['useAs']) ? $data['useAs'] : null;
    }

    /**
     * show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalid_properties = [];

        $allowed_values = $this->getTypeAllowableValues();
        if (!in_array($this->container['type'], $allowed_values)) {
            $invalid_properties[] = sprintf(
                "invalid value for 'type', must be one of '%s'",
                implode("', '", $allowed_values)
            );
        }

        return $invalid_properties;
    }

    /**
     * validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {

        $allowed_values = $this->getTypeAllowableValues();
        if (!in_array($this->container['type'], $allowed_values)) {
            return false;
        }
        return true;
    }


    /**
     * Gets expirationMonth
     * @return string
     */
    public function getExpirationMonth()
    {
        return $this->container['expirationMonth'];
    }

    /**
     * Sets expirationMonth
     * @param string $expirationMonth Credit card expiration month.
     * @return $this
     */
    public function setExpirationMonth($expirationMonth)
    {
        $this->container['expirationMonth'] = $expirationMonth;

        return $this;
    }

    /**
     * Gets expirationYear
     * @return string
     */
    public function getExpirationYear()
    {
        return $this->container['expirationYear'];
    }

    /**
     * Sets expirationYear
     * @param string $expirationYear Credit card expiration year.
     * @return $this
     */
    public function setExpirationYear($expirationYear)
    {
        $this->container['expirationYear'] = $expirationYear;

        return $this;
    }

    /**
     * Gets type
     * @return string
     */
    public function getType()
    {
        return $this->container['type'];
    }

    /**
     * Sets type
     * @param string $type Credit card brand.
     * @return $this
     */
    public function setType($type)
    {
        $allowed_values = $this->getTypeAllowableValues();
        if (!is_null($type) && !in_array($type, $allowed_values)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'type', must be one of '%s'",
                    implode("', '", $allowed_values)
                )
            );
        }
        $this->container['type'] = $type;

        return $this;
    }

    /**
     * Gets issueNumber
     * @return string
     */
    public function getIssueNumber()
    {
        return $this->container['issueNumber'];
    }

    /**
     * Sets issueNumber
     * @param string $issueNumber Credit card issue number.
     * @return $this
     */
    public function setIssueNumber($issueNumber)
    {
        $this->container['issueNumber'] = $issueNumber;

        return $this;
    }

    /**
     * Gets startMonth
     * @return string
     */
    public function getStartMonth()
    {
        return $this->container['startMonth'];
    }

    /**
     * Sets startMonth
     * @param string $startMonth Credit card start month.
     * @return $this
     */
    public function setStartMonth($startMonth)
    {
        $this->container['startMonth'] = $startMonth;

        return $this;
    }

    /**
     * Gets startYear
     * @return string
     */
    public function getStartYear()
    {
        return $this->container['startYear'];
    }

    /**
     * Sets startYear
     * @param string $startYear Credit card start year.
     * @return $this
     */
    public function setStartYear($startYear)
    {
        $this->container['startYear'] = $startYear;

        return $this;
    }

    /**
     * Gets useAs
     * @return string
     */
    public function getUseAs()
    {
        return $this->container['useAs'];
    }

    /**
     * Sets useAs
     * @param string $useAs Card Use As Field. Supported value of \"pinless debit\" only. Only for use with Pinless Debit tokens.
     * @return $this
     */
    public function setUseAs($useAs)
    {
        $this->container['useAs'] = $useAs;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     * @param  integer $offset Offset
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     * @param  integer $offset Offset
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     * @param  integer $offset Offset
     * @param  mixed   $value  Value to be set
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     * @param  integer $offset Offset
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(\CyberSource\ObjectSerializer::sanitizeForSerialization($this), JSON_PRETTY_PRINT);
        }

        return json_encode(\CyberSource\ObjectSerializer::sanitizeForSerialization($this));
    }
}


